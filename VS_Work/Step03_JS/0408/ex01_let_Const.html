<!DOCTYPE html>
<html lang="ko-kr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1> 변수에 대해 - Var, Let, Const
    </h1>
 

    <script>    
        // es5 이전까지는 var로 변수를 선언했다.
        // var의 문제점으로 인해 es6에서 let과 const가 나왔다.
        // 의도하지 않은 전역변수, 중복선언, 스코프 범위 인식 등 var의 문제

        // let과 const는 블록 스코프를 지원한다.
        // 블럭 단위로 유효하므로 var에 비해 수명 주기가 전통적인 언어와 비슷하다.
        // let은 재선언이 불가능하다. (재할당은 가능)

        //let은 선언 이전에 참조하면 참조 에러가 발생한다.
        //console.log(a); // ReferenceError: Cannot access 'a' before initialization
        //temporary dead zone (TDZ) : let과 const로 선언된 변수는 선언되기 전까지 접근할 수 없다.
        
        //함수를 선언하는 방법
        // 1. 함수 선언문 (function statement) : function 키워드로 시작하는 함수 선언문 (선언적 함수)
        //    function test() { ... } : 함수 선언문은 호이스팅이 발생하여, 함수가 선언되기 전에 호출할 수 있다.
        // 2. 함수 표현식 (function expression) : 변수에 함수를 할당하는 함수
        //    var test = function() { ... } : 함수 표현식은 호이스팅이 발생하지 않으므로, 함수가 선언된 후에만 호출할 수 있다. (익명 함수)
        //    var test = function test2() { ... } : 이름이 있는 함수 표현식 (named function expression)으로, 재귀 호출에 사용된다. (이름이이)
        // 3. 즉시 실행 함수 (IIFE) : 함수를 선언과 동시에 호출하는 방법
        // 4. 화살표 함수 (arrow function) : ES6에서 도입된 새로운 함수 선언 방법   
        // 5. 메서드 (method) : 객체의 속성으로 정의된 함수
        // 6. 생성자 함수 (constructor function) : 객체를 생성하기 위한 함수로, 대문자로 시작하는 것이 일반적이다.
        // 7. 클래스 (class) : ES6에서 도입된 새로운 객체 지향 프로그래밍 방식으로, 생성자 함수와 메서드를 포함할 수 있다.
        // 8. 제너레이터 함수 (generator function) : ES6에서 도입된 새로운 함수로, yield 키워드를 사용하여 중간에 실행을 멈추고 값을 반환할 수 있다.
        // 9. async/await 함수 : ES8에서 도입된 새로운 비동기 처리 방식으로, async 키워드를 사용하여 비동기 함수를 정의하고 await 키워드를 사용하여 비동기 처리를 동기적으로 처리할 수 있다.
        // 10. 클로저 (closure) : 함수가 선언될 때의 환경을 기억하는 함수로, 내부 함수가 외부 함수의 변수를 참조할 수 있다. 
        // 11. 콜백 함수 (callback function) : 다른 함수의 인자로 전달되는 함수로, 비동기 처리나 이벤트 처리 등에 사용된다.
        // 12. Promise 함수 : ES6에서 도입된 새로운 비동기 처리 방식으로, 비동기 작업의 결과를 나타내는 객체이다.   

        //함수를 선언할 때 선언적 함수가 아닌 함수 표현식으로 작성하게되면 동일한 이름의 함수를 단 한개만 만들수 있게 된다.
        //즉, 같은 이름을 중복 선언 가능함으로서 발생하는 문제를 방지할 수 있다.
        //함수 표현식으로 작성한 함수는 선언 전에 호출할 수 없다.

        test();// 호출 됨 (호이스팅 동작)

        // 선언적 함수로 함수 선언
        function test(){
            document.write("test hello world 1<br>");
        }

        // let test;
        // let으로는 같은 이름의 함수를 중복 선언할 수 없다. 이미 위에서 test()라는 함수를 선언하면서 이름을 사용했기 때문이다.
        
        //아래와 같은 경우는 가능하다.
        // 위에서 선언된 test를 함수 표현식으로 재정의하는 경우이다.
        test = function (){
            document.write("test hello world 2<br>");
        }

        test();

        // test2(); //호출 안 됨 (함수 표현식으로 선언했으므로)
        let test2 = function (){
            document.write("test hello world 3<br>");
        }

        //const는 상수로 반드시 선언과 동시에 값을 할당해야 한다
        // 한번 초기화되고 나면 값 변경을 할 수 없다. 함수, 객체들은 주로 const로 선언한다.
        // 한번 이름이 결정난 함수를 나중에 변경할 일이 없으므로 const로 선언한다.

        const person = { name: "John", age: 30 };
        person.name = "Jane"; // 객체의 속성은 변경 가능
        // person = { name: "Doe", age: 25 }; // 오류 발생: const로 선언된 변수는 재할당 불가
        console.log(person); // { name: "Jane", age: 30 } 

        // test3(); // 호출 안 됨 (함수 표현식으로 선언했으므므로 )
        
        const test3 = function (){
            document.write("test hello world 4<br>");
        }


        test3();
        // test2는 const로 선언했으므로 재선언할 수 없다.
        // test2 = function(){
        //  document.write("test hello world 3<br>");
        // }

        // test2();

        
    </script>

</body>

</html>